<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Ty (alt-ergo-lib.AltErgoLib.Ty)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.0.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">alt-ergo-lib</a> &#x00BB; <a href="../index.html">AltErgoLib</a> &#x00BB; Ty</nav><header class="odoc-preamble"><h1>Module <code><span>AltErgoLib.Ty</span></code></h1><p>Types</p><p>This module defines the representation of types.</p></header><nav class="odoc-toc"><ul><li><a href="#definition">Definition</a></li><li><a href="#type-inspection">Type inspection</a></li><li><a href="#building-types">Building types</a></li><li><a href="#substitutions">Substitutions</a></li><li><a href="#unification/matching">Unification/Matching</a></li><li><a href="#manipulations-on-types">Manipulations on types</a></li></ul></nav><div class="odoc-content"><h3 id="definition"><a href="#definition" class="anchor"></a>Definition</h3><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = </span></code><table><tr id="type-t.Tint" class="anchored"><td class="def variant constructor"><a href="#type-t.Tint" class="anchor"></a><code><span>| </span><span><span class="constructor">Tint</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Integer numbers</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.Treal" class="anchored"><td class="def variant constructor"><a href="#type-t.Treal" class="anchor"></a><code><span>| </span><span><span class="constructor">Treal</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Real numbers</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.Tbool" class="anchored"><td class="def variant constructor"><a href="#type-t.Tbool" class="anchor"></a><code><span>| </span><span><span class="constructor">Tbool</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Booleans</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.Tunit" class="anchored"><td class="def variant constructor"><a href="#type-t.Tunit" class="anchor"></a><code><span>| </span><span><span class="constructor">Tunit</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The unit type</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.Tvar" class="anchored"><td class="def variant constructor"><a href="#type-t.Tvar" class="anchor"></a><code><span>| </span><span><span class="constructor">Tvar</span> <span class="keyword">of</span> <a href="#type-tvar">tvar</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Type variables</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.Tbitv" class="anchored"><td class="def variant constructor"><a href="#type-t.Tbitv" class="anchor"></a><code><span>| </span><span><span class="constructor">Tbitv</span> <span class="keyword">of</span> int</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Bitvectors of a given length</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.Text" class="anchored"><td class="def variant constructor"><a href="#type-t.Text" class="anchor"></a><code><span>| </span><span><span class="constructor">Text</span> <span class="keyword">of</span> <span><a href="#type-t">t</a> list</span> * <a href="../Hstring/index.html#type-t">Hstring.t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Abstract types applied to arguments. <code>Text (args, s)</code> is the application of the abstract type constructor <code>s</code> to arguments <code>args</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.Tfarray" class="anchored"><td class="def variant constructor"><a href="#type-t.Tfarray" class="anchor"></a><code><span>| </span><span><span class="constructor">Tfarray</span> <span class="keyword">of</span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Functional arrays. <code>TFarray (src,dst)</code> maps values of type <code>src</code> to values of type <code>dst</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.Tsum" class="anchored"><td class="def variant constructor"><a href="#type-t.Tsum" class="anchor"></a><code><span>| </span><span><span class="constructor">Tsum</span> <span class="keyword">of</span> <a href="../Hstring/index.html#type-t">Hstring.t</a> * <span><a href="../Hstring/index.html#type-t">Hstring.t</a> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Enumeration, with its name, and the list of its constructors.</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.Tadt" class="anchored"><td class="def variant constructor"><a href="#type-t.Tadt" class="anchor"></a><code><span>| </span><span><span class="constructor">Tadt</span> <span class="keyword">of</span> <a href="../Hstring/index.html#type-t">Hstring.t</a> * <span><a href="#type-t">t</a> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Algebraic types applied to arguments. <code>Tadt (s, args)</code> is the application of the datatype constructor <code>s</code> to arguments <code>args</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-t.Trecord" class="anchored"><td class="def variant constructor"><a href="#type-t.Trecord" class="anchor"></a><code><span>| </span><span><span class="constructor">Trecord</span> <span class="keyword">of</span> <a href="#type-trecord">trecord</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Record type.</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-tvar" class="anchored"><a href="#type-tvar" class="anchor"></a><code><span><span class="keyword">and</span> tvar</span><span> = </span><span>{</span></code><table><tr id="type-tvar.v" class="anchored"><td class="def record field"><a href="#type-tvar.v" class="anchor"></a><code><span>v : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Unique identifier</p><span class="comment-delim">*)</span></td></tr><tr id="type-tvar.value" class="anchored"><td class="def record field"><a href="#type-tvar.value" class="anchor"></a><code><span><span class="keyword">mutable</span> value : <span><a href="#type-t">t</a> option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Pointer to the current value of the type variable.</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Type variables. The <code>value</code> field is mutated during unification, hence distinct types should have disjoints sets of type variables (see function <a href="#val-fresh"><code>fresh</code></a>).</p></div></div><div class="odoc-spec"><div class="spec type" id="type-trecord" class="anchored"><a href="#type-trecord" class="anchor"></a><code><span><span class="keyword">and</span> trecord</span><span> = </span><span>{</span></code><table><tr id="type-trecord.args" class="anchored"><td class="def record field"><a href="#type-trecord.args" class="anchor"></a><code><span><span class="keyword">mutable</span> args : <span><a href="#type-t">t</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Arguments passed to the record constructor</p><span class="comment-delim">*)</span></td></tr><tr id="type-trecord.name" class="anchored"><td class="def record field"><a href="#type-trecord.name" class="anchor"></a><code><span>name : <a href="../Hstring/index.html#type-t">Hstring.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Name of the record type</p><span class="comment-delim">*)</span></td></tr><tr id="type-trecord.lbs" class="anchored"><td class="def record field"><a href="#type-trecord.lbs" class="anchor"></a><code><span><span class="keyword">mutable</span> lbs : <span><span>(<a href="../Hstring/index.html#type-t">Hstring.t</a> * <a href="#type-t">t</a>)</span> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>List of fields of the record. Each field has a name, and an associated type.</p><span class="comment-delim">*)</span></td></tr><tr id="type-trecord.record_constr" class="anchored"><td class="def record field"><a href="#type-trecord.record_constr" class="anchor"></a><code><span>record_constr : <a href="../Hstring/index.html#type-t">Hstring.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>record constructor. Useful is case it's a specialization of an algeberaic datatype. Default value is &quot;{__<code>name</code>&quot;</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Record types.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-adt_constr" class="anchored"><a href="#type-adt_constr" class="anchor"></a><code><span><span class="keyword">type</span> adt_constr</span><span> = </span><span>{</span></code><table><tr id="type-adt_constr.constr" class="anchored"><td class="def record field"><a href="#type-adt_constr.constr" class="anchor"></a><code><span>constr : <a href="../Hstring/index.html#type-t">Hstring.t</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>constructor of an ADT type</p><span class="comment-delim">*)</span></td></tr><tr id="type-adt_constr.destrs" class="anchored"><td class="def record field"><a href="#type-adt_constr.destrs" class="anchor"></a><code><span>destrs : <span><span>(<a href="../Hstring/index.html#type-t">Hstring.t</a> * <a href="#type-t">t</a>)</span> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>the list of destructors associated with the constructor and their respective types</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div></div><div class="odoc-spec"><div class="spec type" id="type-type_body" class="anchored"><a href="#type-type_body" class="anchor"></a><code><span><span class="keyword">type</span> type_body</span><span> = </span></code><table><tr id="type-type_body.Adt" class="anchored"><td class="def variant constructor"><a href="#type-type_body.Adt" class="anchor"></a><code><span>| </span><span><span class="constructor">Adt</span> <span class="keyword">of</span> <span><a href="#type-adt_constr">adt_constr</a> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>body of an algebraic datatype</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>bodies of types definitions. Currently, bodies are inlined in the type <code>t</code> for records and enumerations. But, this is not possible for recursive ADTs</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Svty" class="anchored"><a href="#module-Svty" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Svty</span><span> : <span class="xref-unresolved">Stdlib</span>.Set.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">elt</span> = <span class="xref-unresolved">int</span></span></span></code></div><div class="spec-doc"><p>Sets of type variables, indexed by their identifier.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Set" class="anchored"><a href="#module-Set" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>Set</span><span> : <span class="xref-unresolved">Stdlib</span>.Set.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">elt</span> = <span class="xref-unresolved">t</span></span></span></code></div><div class="spec-doc"><p>Sets of types</p></div></div><div class="odoc-spec"><div class="spec value" id="val-assoc_destrs" class="anchored"><a href="#val-assoc_destrs" class="anchor"></a><code><span><span class="keyword">val</span> assoc_destrs : <span><a href="../Hstring/index.html#type-t">Hstring.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-adt_constr">adt_constr</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span>(<a href="../Hstring/index.html#type-t">Hstring.t</a> * <a href="#type-t">t</a>)</span> list</span></span></code></div><div class="spec-doc"><p>returns the list of destructors associated with the given consturctor. raises Not_found if the constructor is not in the given list</p></div></div><div class="odoc-spec"><div class="spec value" id="val-type_body" class="anchored"><a href="#val-type_body" class="anchor"></a><code><span><span class="keyword">val</span> type_body : <span><a href="../Hstring/index.html#type-t">Hstring.t</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-type_body">type_body</a></span></code></div></div><h3 id="type-inspection"><a href="#type-inspection" class="anchor"></a>Type inspection</h3><div class="odoc-spec"><div class="spec value" id="val-hash" class="anchored"><a href="#val-hash" class="anchor"></a><code><span><span class="keyword">val</span> hash : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Hash function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal" class="anchored"><a href="#val-equal" class="anchor"></a><code><span><span class="keyword">val</span> equal : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Equality function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare" class="anchored"><a href="#val-compare" class="anchor"></a><code><span><span class="keyword">val</span> compare : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Comparison function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-print" class="anchored"><a href="#val-print" class="anchor"></a><code><span><span class="keyword">val</span> print : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Printing function for types (does not print the type of each fields for records).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-print_list" class="anchored"><a href="#val-print_list" class="anchor"></a><code><span><span class="keyword">val</span> print_list : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print function for lists of types (does not print the type of each fields for records).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-print_full" class="anchored"><a href="#val-print_full" class="anchor"></a><code><span><span class="keyword">val</span> print_full : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print function including the record fields.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-vty_of" class="anchored"><a href="#val-vty_of" class="anchor"></a><code><span><span class="keyword">val</span> vty_of : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span class="xref-unresolved">Svty</span>.t</span></code></div><div class="spec-doc"><p>Returns the set of type variables that occur in a given type.</p></div></div><h3 id="building-types"><a href="#building-types" class="anchor"></a>Building types</h3><div class="odoc-spec"><div class="spec value" id="val-tunit" class="anchored"><a href="#val-tunit" class="anchor"></a><code><span><span class="keyword">val</span> tunit : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>The unit type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fresh_var" class="anchored"><a href="#val-fresh_var" class="anchor"></a><code><span><span class="keyword">val</span> fresh_var : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-tvar">tvar</a></span></code></div><div class="spec-doc"><p>Generate a fresh type variable, guaranteed to be distinct from any other previously generated by this function.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fresh_tvar" class="anchored"><a href="#val-fresh_tvar" class="anchor"></a><code><span><span class="keyword">val</span> fresh_tvar : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Wrap the <a href="#val-fresh_var"><code>fresh_var</code></a> function to return a type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fresh_empty_text" class="anchored"><a href="#val-fresh_empty_text" class="anchor"></a><code><span><span class="keyword">val</span> fresh_empty_text : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Return a fesh abstract type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-text" class="anchored"><a href="#val-text" class="anchor"></a><code><span><span class="keyword">val</span> text : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Apply the abstract type constructor to the list of type arguments given.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-tsum" class="anchored"><a href="#val-tsum" class="anchor"></a><code><span><span class="keyword">val</span> tsum : <span>string <span class="arrow">&#45;&gt;</span></span> <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create an enumeration type. <code>tsum name enums</code> creates an enumeration named <code>name</code>, with constructors <code>enums</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-t_adt" class="anchored"><a href="#val-t_adt" class="anchor"></a><code><span><span class="keyword">val</span> t_adt : <span>?body:<span><span><span>(string * <span><span>(string * <a href="#type-t">t</a>)</span> list</span>)</span> list</span> option</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Crearte and algebraic datatype. The body is a list of constructors, where each constructor is associated with the list of its destructors with their respective types. If <code>body</code> is none, then no definition will be registered for this type. The second argument is the name of the type. The third one provides its list of arguments.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-trecord" class="anchored"><a href="#val-trecord" class="anchor"></a><code><span><span class="keyword">val</span> trecord : <span>?record_constr:string <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><span><span>(string * <a href="#type-t">t</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Create a record type. <code>trecord args name lbs</code> creates a record type with name <code>name</code>, arguments <code>args</code> and fields <code>lbs</code>.</p></div></div><h3 id="substitutions"><a href="#substitutions" class="anchor"></a>Substitutions</h3><div class="odoc-spec"><div class="spec module" id="module-M" class="anchored"><a href="#module-M" class="anchor"></a><code><span><span class="keyword">module</span> </span><span>M</span><span> : <span class="xref-unresolved">Stdlib</span>.Map.S <span class="keyword">with</span> <span><span class="keyword">type</span> <span class="xref-unresolved">key</span> = <span class="xref-unresolved">int</span></span></span></code></div><div class="spec-doc"><p>Maps from type variables identifiers.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-subst" class="anchored"><a href="#type-subst" class="anchor"></a><code><span><span class="keyword">type</span> subst</span><span> = <span><a href="#type-t">t</a> <span class="xref-unresolved">M</span>.t</span></span></code></div><div class="spec-doc"><p>The type of substitution, i.e. maps from type variables identifiers to types.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compare_subst" class="anchored"><a href="#val-compare_subst" class="anchor"></a><code><span><span class="keyword">val</span> compare_subst : <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Comparison of substitutions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-equal_subst" class="anchored"><a href="#val-equal_subst" class="anchor"></a><code><span><span class="keyword">val</span> equal_subst : <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Equality of substitutions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-print_subst" class="anchored"><a href="#val-print_subst" class="anchor"></a><code><span><span class="keyword">val</span> print_subst : <span><span class="xref-unresolved">Stdlib</span>.Format.formatter <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Print function for substitutions.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-esubst" class="anchored"><a href="#val-esubst" class="anchor"></a><code><span><span class="keyword">val</span> esubst : <a href="#type-subst">subst</a></span></code></div><div class="spec-doc"><p>The empty substitution, a.k.a. the identity.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-apply_subst" class="anchored"><a href="#val-apply_subst" class="anchor"></a><code><span><span class="keyword">val</span> apply_subst : <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Substitution application.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-union_subst" class="anchored"><a href="#val-union_subst" class="anchor"></a><code><span><span class="keyword">val</span> union_subst : <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-subst">subst</a></span></code></div><div class="spec-doc"><p><code>union_subst u v</code> applies <code>v</code> to <code>u</code>, resulting in <code>u'</code>. It then computes the union of <code>u'</code> and <code>v</code>, prioritizing bindings from <code>u'</code> in case of conflict.</p></div></div><h3 id="unification/matching"><a href="#unification/matching" class="anchor"></a>Unification/Matching</h3><div class="odoc-spec"><div class="spec exception" id="exception-TypeClash" class="anchored"><a href="#exception-TypeClash" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">TypeClash</span> <span class="keyword">of</span> <a href="#type-t">t</a> * <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Exception raised during matching or unification. <code>TypeClash (u, v)</code> is raised when <code>u</code> and <code>v</code> could not be matched or unified (<code>u</code> and <code>v</code> may be sub-types of the types being actually unified or matched).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unify" class="anchored"><a href="#val-unify" class="anchor"></a><code><span><span class="keyword">val</span> unify : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Destructive unification. Mutates the <code>value</code> fields of type variables.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">TypeClash</span> <p>when unification is impossible. In this case, the <code>value</code> fields of already mutated type variables are left modified, which may prevent future unifications.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-matching" class="anchored"><a href="#val-matching" class="anchor"></a><code><span><span class="keyword">val</span> matching : <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-subst">subst</a></span></code></div><div class="spec-doc"><p>Matching of types (non-destructive). <code>matching pat t</code> returns a substitution <code>subst</code> such that <code>apply_subst subst pat</code> is equal to <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-shorten" class="anchored"><a href="#val-shorten" class="anchor"></a><code><span><span class="keyword">val</span> shorten : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Shorten paths in type variables values. Unification in particular can create chains where the <code>value</code> field of one type variable points to another and so on... This function short-circuits such chains so that the value of a type variable can be accessed directly.</p></div></div><h3 id="manipulations-on-types"><a href="#manipulations-on-types" class="anchor"></a>Manipulations on types</h3><div class="odoc-spec"><div class="spec value" id="val-fresh" class="anchored"><a href="#val-fresh" class="anchor"></a><code><span><span class="keyword">val</span> fresh : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a> * <a href="#type-subst">subst</a></span></code></div><div class="spec-doc"><p>Apply the given substitution, all while generating fresh variables for the variables not already bound in the substitution. Returns a substitution containing bindings from old variable to their fresh counterpart.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fresh_list" class="anchored"><a href="#val-fresh_list" class="anchor"></a><code><span><span class="keyword">val</span> fresh_list : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-subst">subst</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> list</span> * <a href="#type-subst">subst</a></span></code></div><div class="spec-doc"><p>Same as <a href="#val-fresh"><code>fresh</code></a> but on lists of types.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-instantiate" class="anchored"><a href="#val-instantiate" class="anchor"></a><code><span><span class="keyword">val</span> instantiate : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>instantiate vars args t</code> builds the substitutions mapping each type variable in <code>vars</code> to the corresponding term in <code>args</code>, then apply that substitution to <code>t</code>.</p><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Invalid_argument</span> <p>if the lists <code>vars</code> and <code>args</code> do not have the same length</p></li></ul><ul class="at-tags"><li class="raises"><span class="at-tag">raises</span> <span class="value">Assertion_failure</span> <p>if one type in <code>vars</code> is not a type variable.</p></li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-monomorphize" class="anchored"><a href="#val-monomorphize" class="anchor"></a><code><span><span class="keyword">val</span> monomorphize : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p>Return a monomorphized variant of the given type, where type variable without values have been replaced by abstract types.</p></div></div></div></body></html>